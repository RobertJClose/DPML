{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>The Double Precision Maths Library is a free code library for users of the Unity game engine. </p> <p>The library contains classes such as <code>Vector3d</code> and <code>Quaterniond</code>, which should be instantly familiar to users of Unity. While the Unity maths and physics classes are backed by single precision floating-point data types, the classes of this library are backed by double precision floats. </p> <p>The higher precision types allow for more accurate physical simulations, as floating-point rounding errors are minimised. This may be helpful when performing simulations of orbital mechanics for example, where centimetre precision may still be required across astronomical distances. </p> <p>Be cognizant of the fact that the higher precision floats will affect both memory usage and performance.</p>"},{"location":"#installation","title":"Installation","text":"<p>The library may be found for free on the Unity Asset Store here. Once you have added the asset to your account, you can install it into your projects via the Unity Package Manager.</p>"},{"location":"#style-of-this-documentation","title":"Style Of This Documentation","text":"<p>Every class in this library has an equivalent class in the built-in Unity scripting API. These classes have been designed to be as similar to their Unity equivalents as possible. For that reason, the standard Unity documentation can largely serve as documentation for this library. </p> <p>However, there are a handful of places where the behaviour of this library differs slightly from the Unity implementation. There are also some methods from the Unity classes which are not implemented by this library. This documentation seeks only to record all the differences and missing methods.</p>"},{"location":"#contents-of-this-library","title":"Contents Of This Library","text":"<p>The classes included in this library are the following:</p> <ul> <li><code>Mathd</code></li> <li><code>Matrix4x4d</code></li> <li><code>Quaterniond</code></li> <li><code>Vector2d</code></li> <li><code>Vector3d</code> </li> <li><code>Vector4d</code></li> </ul> <p>As mentioned above, some of equivalent Unity methods are not implemented by this library. This was done for one of two reasons:</p> <ol> <li>A double precision version of the method seemed unlikely to offer much practical benefit.</li> <li>The behaviour of the Unity method could not be reproduced with sufficient accuracy.</li> </ol> <p>If there a method missing from this library that you feel should be implemented, please feel free to get in touch and I will look into it.</p>"},{"location":"Mathd/","title":"Mathd","text":"<p>Unity equivalent documentation: https://docs.unity3d.com/ScriptReference/Mathf.html</p>"},{"location":"Mathd/#unimplemented-methods","title":"Unimplemented Methods","text":"<ul> <li><code>ClosestPowerOfTwo()</code></li> <li><code>CorrelatedColorTemperatureToRGB()</code></li> <li><code>DoubleToHalf()</code></li> <li><code>GammaToLinearSpace()</code></li> <li><code>HalfToDouble()</code></li> <li><code>IsPowerOfTwo()</code></li> <li><code>LinearToGammaSpace()</code></li> <li><code>NextPowerOfTwo()</code></li> <li><code>PerlinNoise()</code></li> <li><code>PerlinNoise1D()</code></li> <li><code>SmoothDamp()</code></li> <li><code>SmothDampAngle()</code></li> <li><code>SmoothStep()</code></li> </ul>"},{"location":"Mathd/#known-differences-between-implemented-methods","title":"Known Differences Between Implemented Methods","text":"<p>None.</p>"},{"location":"Matrix4x4d/","title":"Matrix4x4d","text":"<p>Unity equivalent documentation: https://docs.unity3d.com/ScriptReference/Matrix4x4.html</p>"},{"location":"Matrix4x4d/#unimplemented-methods","title":"Unimplemented Methods","text":"<p>None.</p>"},{"location":"Matrix4x4d/#known-differences-between-implemented-methods","title":"Known Differences Between Implemented Methods","text":"<ul> <li><code>TRS()</code> and <code>SetTRS()</code> - When given a non-unit quaternion as input, the Unity implementations of these methods log an error, before some matrix is constructed. My implementation in this case does not log an error, but normalises the input quaternion before constructing a valid TRS matrix. In the standard case when the input quaternion has unit magnitude, the methods behave identically.</li> <li><code>rotation</code> - There is a special case for matrices which sometimes results in different output between this library and the Unity <code>rotation</code> property. When a matrix contains a net reflection in its <code>scale</code> vector, the axis of reflection is ambiguous. A reflection along any one axis is equivalent to a reflection along a different axis, combined with a rotation. If you change which axis you consider the reflection to have occurred along, then you can get the same transformation by changing the rotation. My <code>rotation</code> property always considers a net reflection to have occurred along the x-axis. The Unity <code>rotation</code> property appears to change which axis it considers the reflection along. The combined <code>scale</code> and <code>rotation</code> properties taken together as a transformation should still be consistent with the Unity implementation.</li> <li><code>Equals()</code> and <code>== (Operator)</code> - There is no Unity documentation on these operations, but they do exist for the built in <code>Matrix4x4</code>. I believe that the <code>==</code> operator uses the <code>Mathf.Approximately()</code> method in order to test for approximate equality, while the <code>Equals()</code> method tests for exact equality. This is the behaviour implemented in this library.</li> </ul>"},{"location":"Quaterniond/","title":"Quaternion","text":"<p>Unity equivalent documentation: https://docs.unity3d.com/ScriptReference/Quaternion.html</p>"},{"location":"Quaterniond/#unimplemented-methods","title":"Unimplemented Methods","text":"<ul> <li><code>RotateTowards()</code></li> </ul>"},{"location":"Quaterniond/#known-differences-between-implemented-methods","title":"Known Differences Between Implemented Methods","text":"<ul> <li><code>Slerp()</code> and <code>SlerpUnclamped()</code> - When slerping between directions separated by 180 degrees, there is no unique path to slerp along. This library will produce a valid <code>Slerp()</code>, but in general it will not exactly match the <code>Slerp()</code> produced by the Unity methods.</li> </ul>"},{"location":"Vector2d/","title":"Vector2d","text":"<p>Unity equivalent documentation: https://docs.unity3d.com/ScriptReference/Vector2.html</p>"},{"location":"Vector2d/#unimplemented-methods","title":"Unimplemented Methods","text":"<ul> <li><code>SmoothDamp()</code></li> </ul>"},{"location":"Vector2d/#known-differences-between-implemented-methods","title":"Known Differences Between Implemented Methods","text":"<p>None.</p>"},{"location":"Vector3d/","title":"Vector3d","text":"<p>Unity equivalent documentation: https://docs.unity3d.com/ScriptReference/Vector3.html</p>"},{"location":"Vector3d/#unimplemented-methods","title":"Unimplemented Methods","text":"<ul> <li><code>RotateTowards()</code></li> <li><code>SmoothDamp()</code></li> </ul>"},{"location":"Vector3d/#known-differences-between-implemented-methods","title":"Known Differences Between Implemented Methods","text":"<ul> <li><code>Slerp()</code> and <code>SlerpUnclamped()</code> - When slerping between directions separated by 180 degrees, there is no unique path to slerp along. This library will produce a valid <code>Slerp()</code>, but in general it will not exactly match the <code>Slerp()</code> produced by the built-in Unity methods.</li> </ul>"},{"location":"Vector4d/","title":"Vector4d","text":"<p>Unity equivalent documentation: https://docs.unity3d.com/ScriptReference/Vector4.html</p>"},{"location":"Vector4d/#unimplemented-methods","title":"Unimplemented Methods","text":"<p>None.</p>"},{"location":"Vector4d/#known-differences-between-implemented-methods","title":"Known Differences Between Implemented Methods","text":"<p>None.</p>"}]}